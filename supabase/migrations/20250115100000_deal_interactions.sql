-- Deal Interactions Table
create table "public"."dealInteractions" (
  "id" bigint generated by default as identity not null,
  "deal_id" bigint not null,
  "type" text not null check (type in ('Email', 'Chiamata', 'Meeting', 'Demo', 'Proposta', 'Negoziazione', 'Follow-up', 'Altro')),
  "date" timestamp with time zone not null default now(),
  "duration" integer, -- minutes for calls/meetings
  "participants" bigint[], -- contact_ids involved
  "notes" text,
  "attachments" jsonb[],
  "sentiment" text check (sentiment in ('Positivo', 'Neutro', 'Negativo', 'Critico')),
  "sales_id" bigint,
  "created_at" timestamp with time zone not null default now()
);

alter table "public"."dealInteractions" enable row level security;

CREATE UNIQUE INDEX "dealInteractions_pkey" ON public."dealInteractions" USING btree (id);

alter table "public"."dealInteractions" add constraint "dealInteractions_pkey" PRIMARY KEY using index "dealInteractions_pkey";

alter table "public"."dealInteractions" add constraint "dealInteractions_deal_id_fkey" 
  foreign key (deal_id) references deals(id) on update cascade on delete cascade not valid;

alter table "public"."dealInteractions" validate constraint "dealInteractions_deal_id_fkey";

alter table "public"."dealInteractions" add constraint "dealInteractions_sales_id_fkey" 
  foreign key (sales_id) references sales(id) not valid;

alter table "public"."dealInteractions" validate constraint "dealInteractions_sales_id_fkey";

-- RLS policies
create policy "Enable all for authenticated users" on "public"."dealInteractions" 
  as permissive for all to authenticated using (true) with check (true);

-- Grants
grant delete on table "public"."dealInteractions" to authenticated;
grant insert on table "public"."dealInteractions" to authenticated;
grant select on table "public"."dealInteractions" to authenticated;
grant update on table "public"."dealInteractions" to authenticated;

grant delete on table "public"."dealInteractions" to service_role;
grant insert on table "public"."dealInteractions" to service_role;
grant references on table "public"."dealInteractions" to service_role;
grant select on table "public"."dealInteractions" to service_role;
grant trigger on table "public"."dealInteractions" to service_role;
grant truncate on table "public"."dealInteractions" to service_role;
grant update on table "public"."dealInteractions" to service_role;

-- Timers Table
create table "public"."timers" (
  "id" uuid default gen_random_uuid() not null,
  "entity_type" text not null check (entity_type in ('opportunity', 'lead', 'customer', 'task', 'proposal')),
  "entity_id" text not null,
  "timer_type" text not null check (timer_type in ('relative', 'absolute')),
  "trigger_event" text, -- for relative: 'creation', 'stage_change', 'last_interaction', 'custom_field_update'
  "delay_value" integer, -- for relative timers
  "delay_unit" text check (delay_unit in ('minutes', 'hours', 'days', 'weeks')),
  "fixed_datetime" timestamp with time zone, -- for absolute timers
  "priority" text not null check (priority in ('low', 'medium', 'high', 'urgent')),
  "action_required" text not null,
  "description" text,
  "assigned_to" bigint not null,
  "notify_also" bigint[], -- additional user_ids to notify
  "channels" text[] default array['in_app', 'email'],
  "recurrence_enabled" boolean default false,
  "recurrence_pattern" text check (recurrence_pattern in ('daily', 'weekly', 'monthly', 'custom')),
  "recurrence_interval" integer default 1,
  "recurrence_end_condition" text check (recurrence_end_condition in ('never', 'after_n_times', 'until_date')),
  "recurrence_end_value" text,
  "status" text not null default 'active' check (status in ('active', 'paused', 'expired', 'completed')),
  "last_triggered" timestamp with time zone,
  "next_trigger" timestamp with time zone,
  "trigger_count" integer default 0,
  "created_at" timestamp with time zone not null default now(),
  "created_by" bigint not null
);

alter table "public"."timers" enable row level security;

CREATE UNIQUE INDEX timers_pkey ON public.timers USING btree (id);

alter table "public"."timers" add constraint "timers_pkey" PRIMARY KEY using index "timers_pkey";

alter table "public"."timers" add constraint "timers_assigned_to_fkey" 
  foreign key (assigned_to) references sales(id) not valid;

alter table "public"."timers" validate constraint "timers_assigned_to_fkey";

alter table "public"."timers" add constraint "timers_created_by_fkey" 
  foreign key (created_by) references sales(id) not valid;

alter table "public"."timers" validate constraint "timers_created_by_fkey";

create policy "Enable all for authenticated users" on "public"."timers"
  as permissive for all to authenticated using (true) with check (true);

grant delete on table "public"."timers" to authenticated;
grant insert on table "public"."timers" to authenticated;
grant select on table "public"."timers" to authenticated;
grant update on table "public"."timers" to authenticated;

grant delete on table "public"."timers" to service_role;
grant insert on table "public"."timers" to service_role;
grant references on table "public"."timers" to service_role;
grant select on table "public"."timers" to service_role;
grant trigger on table "public"."timers" to service_role;
grant truncate on table "public"."timers" to service_role;
grant update on table "public"."timers" to service_role;

-- Notifications Table
create table "public"."notifications" (
  "id" bigint generated by default as identity not null,
  "timer_id" uuid,
  "user_id" bigint not null,
  "title" text not null,
  "message" text not null,
  "priority" text not null,
  "read" boolean default false,
  "entity_type" text,
  "entity_id" text,
  "created_at" timestamp with time zone not null default now()
);

alter table "public"."notifications" enable row level security;

CREATE UNIQUE INDEX notifications_pkey ON public.notifications USING btree (id);

alter table "public"."notifications" add constraint "notifications_pkey" PRIMARY KEY using index "notifications_pkey";

alter table "public"."notifications" add constraint "notifications_timer_id_fkey" 
  foreign key (timer_id) references timers(id) on delete cascade not valid;

alter table "public"."notifications" validate constraint "notifications_timer_id_fkey";

alter table "public"."notifications" add constraint "notifications_user_id_fkey" 
  foreign key (user_id) references sales(id) on delete cascade not valid;

alter table "public"."notifications" validate constraint "notifications_user_id_fkey";

create policy "Users see own notifications" on "public"."notifications"
  as permissive for select to authenticated using (user_id = (select id from sales where user_id = auth.uid()));

create policy "Enable insert for authenticated" on "public"."notifications"
  as permissive for insert to authenticated with check (true);

create policy "Users update own notifications" on "public"."notifications"
  as permissive for update to authenticated using (user_id = (select id from sales where user_id = auth.uid()));

grant select on table "public"."notifications" to authenticated;
grant insert on table "public"."notifications" to authenticated;
grant update on table "public"."notifications" to authenticated;

grant delete on table "public"."notifications" to service_role;
grant insert on table "public"."notifications" to service_role;
grant references on table "public"."notifications" to service_role;
grant select on table "public"."notifications" to service_role;
grant trigger on table "public"."notifications" to service_role;
grant truncate on table "public"."notifications" to service_role;
grant update on table "public"."notifications" to service_role;

-- Indexes for performance
create index notifications_user_id_read_idx on notifications(user_id, read);
create index notifications_created_at_idx on notifications(created_at desc);
create index timers_next_trigger_idx on timers(next_trigger) where status = 'active';
create index dealInteractions_deal_id_idx on "dealInteractions"(deal_id);

-- Function to calculate next trigger time for a timer
create or replace function calculate_next_trigger(timer_record timers)
returns timestamp with time zone
language plpgsql
as $$
declare
  next_time timestamp with time zone;
begin
  if timer_record.timer_type = 'absolute' then
    return timer_record.fixed_datetime;
  elsif timer_record.timer_type = 'relative' then
    -- Calculate based on delay
    case timer_record.delay_unit
      when 'minutes' then
        next_time := now() + (timer_record.delay_value || ' minutes')::interval;
      when 'hours' then
        next_time := now() + (timer_record.delay_value || ' hours')::interval;
      when 'days' then
        next_time := now() + (timer_record.delay_value || ' days')::interval;
      when 'weeks' then
        next_time := now() + (timer_record.delay_value || ' weeks')::interval;
    end case;
    return next_time;
  end if;
  return null;
end;
$$;

-- Trigger to set next_trigger on timer creation
create or replace function set_timer_next_trigger()
returns trigger
language plpgsql
as $$
begin
  NEW.next_trigger := calculate_next_trigger(NEW);
  return NEW;
end;
$$;

create trigger on_timer_created
  before insert on timers
  for each row
  execute function set_timer_next_trigger();


